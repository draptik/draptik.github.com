<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Raspberry Pi | draptik]]></title>
  <link href="http://draptik.github.io/blog/categories/raspberry-pi/atom.xml" rel="self"/>
  <link href="http://draptik.github.io/"/>
  <updated>2015-07-16T20:51:22+02:00</updated>
  <id>http://draptik.github.io/</id>
  <author>
    <name><![CDATA[Patrick Drechsler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remotly measuring temperatures with a Raspberry Pi using radio frequency modules from Ciseco (Part 1: Hardware)]]></title>
    <link href="http://draptik.github.io/blog/2015/07/10/remotly-measuring-temperatures-with-a-raspberry-pi-using-radio-frequency-modules-from-ciseco-part-1-hardware/"/>
    <updated>2015-07-10T00:11:00+02:00</updated>
    <id>http://draptik.github.io/blog/2015/07/10/remotly-measuring-temperatures-with-a-raspberry-pi-using-radio-frequency-modules-from-ciseco-part-1-hardware</id>
    <content type="html"><![CDATA[<p>Since I&rsquo;m a software developer, I&rsquo;ve always been wanting to do some hardware stuff (including some soldering) with my Raspberry Pi.
So, for starters, I picked something that was useful and only involved sensors (no actors &ndash; yet):</p>

<p>Measuring temperatures at home.</p>

<p>Neither rocket science nor cool IoT &ldquo;coffe is ready when I get out of the shower in the morning&rdquo;, I know.</p>

<p>The sensor(s) should send a signal once an hour, without cable, and run on battery.</p>

<p>As the whole IoT thing is still relatively new, there are no standards yet. I picked the product line from <a href="http://shop.ciseco.co.uk/">Ciseco</a> (<a href="http://shop.ciseco.co.uk/about-us/">currently being rebranded to Wireless Things (www.wirelessthings.com)</a>). Affordable and good documentation. And, more important: These people are passionate about their product!</p>

<p>So let&rsquo;s get started:</p>

<ul>
<li>2 battery powered sensors transmitting temperature data once per hour via radio frequency.</li>
<li>Raspberry Pi is powered 24/7 and records signals from sensors.</li>
</ul>


<h2>Parts &amp; Costs</h2>

<ul>
<li>1x 3.90 GBP Slice of Pi <a href="http://shop.ciseco.co.uk/slice-of-pi-add-on-for-raspberry-pi/">http://shop.ciseco.co.uk/slice-of-pi-add-on-for-raspberry-pi/</a></li>
<li>2x 8.50 GBP Sensor THERMISTOR <a href="http://shop.ciseco.co.uk/temperature-xrf-development-sensor-thermistor/">http://shop.ciseco.co.uk/temperature-xrf-development-sensor-thermistor/</a></li>
<li>3x 11.88 BGP XRF wireless RF radio UART serial data module <a href="http://shop.ciseco.co.uk/xrf-wireless-rf-radio-uart-serial-data-module-xbee-shaped/">http://shop.ciseco.co.uk/xrf-wireless-rf-radio-uart-serial-data-module-xbee-shaped/</a></li>
</ul>


<p>Total: 56.54 GBP</p>

<p>If you only want a single sensor (1 Slice of Pi, 1 Sensor, 2 XRF modules): 36.16 GBP</p>

<h2>Hardware: Fitting the pieces &amp; soldering</h2>

<p>The official documentation is pretty good. If you know what you&rsquo;re doing.</p>

<ul>
<li>For the Slice of Pi: <a href="http://openmicros.org/GSG/Slice%20of%20Pi%20-%20v1-1%20getting%20started%20guide.pdf">http://openmicros.org/GSG/Slice%20of%20Pi%20-%20v1-1%20getting%20started%20guide.pdf</a></li>
<li>For the sensor module(s): <a href="http://openmicros.org/index.php/articles/88-ciseco-product-documentation/211-ccb-coin-cell-board-pictorial-build-guide">http://openmicros.org/index.php/articles/88-ciseco-product-documentation/211-ccb-coin-cell-board-pictorial-build-guide</a></li>
</ul>


<p>In case you are not really sure what you are doing with the soldering iron: Keep calm. There is a lot of information on the internet. I found the following step-by-step instruction useful:</p>

<p><a href="http://www.pihomeserver.fr/en/2013/07/11/raspberry-pi-assembler-un-emetteur-radio-pour-votre-sonde-de-temperature/">Raspberry Pi &ndash; Assemble your temperature THERMISTOR with an XRF transmitter probe</a></p>

<p>Note: The sensor comes with a box. In case you want to place the sensor inside the box make sure <strong>not to solder the thermistor to close to the board</strong>. You will want to make a hole in the box and have the thermistor stick out. Otherwise the thermistor will be inside the closed box and measure the temperature inside the box (instead of outside the box). Here is a picture illustrating the issue:</p>

<p><img src="/images/posts/rpi_temperatures/sensor.png"></p>

<h2>OS</h2>

<p>This is one of the reasons I picked Ciseco for my simple project: They provide a standard Linux distribution (Raspbian) including their drivers.</p>

<p>This means the &ldquo;Slice of Pi&rdquo; works out of the box.</p>

<p>And the rest of the system behaves like a normal Raspbian system. There is no vendor &ldquo;lock-in&rdquo;.</p>

<p>Ciseco&rsquo;s patched version of Raspbian <a href="http://openmicros.org/Download/">here</a>.
Currently this is <a href="http://openmicros.org/Download/2015-05-05-raspbain-wheezy-raswik-shrunk.img.zip">http://openmicros.org/Download/2015-05-05-raspbain-wheezy-raswik-shrunk.img.zip</a>.
I used the slightly older version <a href="http://openmicros.org/Download/2014-12-24-wheezy-raspbian-ciseco-shrunk.img.zip">http://openmicros.org/Download/2014-12-24-wheezy-raspbian-ciseco-shrunk.img.zip</a>.</p>

<h2>Software (well, actually Firmware)</h2>

<p>All parts are soldered and the RPi has the correct operating system.</p>

<p>Our next steps (from a bird&rsquo;s eye perspective) are:</p>

<ul>
<li>uploading the correct firmware onto the sensors' XRF module</li>
<li>configuring the sensors' XRF module</li>
</ul>


<p>The following instructions are mostly taken from <a href="http://www.seanlandsman.com/2013/02/the-raspberry-pi-and-wireless-rf-xrf.html">Sean Landsman&rsquo;s excellent tutorial</a>.</p>

<h3>Upload firmware to sensor(s)&lsquo; XRF module</h3>

<p>Why do we have to do this?</p>

<p>The sensor board is generic and can be configured for working with different types of sensors. We&rsquo;re using a thermistor, in case you forgot&hellip; The thing with the antenna is the XRF module. We have 3 XRF modules: 1 for receiving data, 2 for sending data. We&rsquo;ll take care of the sending modules first.</p>

<p>The tool for uploading the appropriate firmware to XRF modules is called <code>xrf_uploader</code>.</p>

<p>Download the <code>xrf_uploader</code> source code from Ciseco&rsquo;s Github page at <a href="https://github.com/CisecoPlc/XRF-Uploader">https://github.com/CisecoPlc/XRF-Uploader</a> to the Raspberry Pi.</p>

<p>Then compile the file <code>xrf_uploader.cpp</code>:</p>

<p><code>sh
g++ xfr_uploader.cpp -o xrf_uploader
chmod +x xrf_uploader
</code></p>

<p>Next, get a copy of the thermistor firmware from Ciseco&rsquo;s Github page at <a href="https://github.com/CisecoPlc/XRF-Firmware-downloads/tree/master/XRFV2%20ARF%20SRF%20-%20LLAP">https://github.com/CisecoPlc/XRF-Firmware-downloads/tree/master/XRFV2%20ARF%20SRF%20-%20LLAP</a>.
At the time of writing, the most current version of the termistor firmware was <a href="https://github.com/CisecoPlc/XRF-Firmware-downloads/blob/master/XRFV2%20ARF%20SRF%20-%20LLAP/llapThermistor-V0.73-24MHz.bin">llapThermistor-V0.73-24MHz.bin</a>.</p>

<ul>
<li>Shutdown the Raspberry Pi (<code>sudo init 0</code>)</li>
<li>Connect the first XRF &lsquo;sensor&rsquo; module with the Slice of Pi</li>
<li>Start the Raspberry Pi again</li>
</ul>


<p>Copy the thermistor firmware into the same folder as the <code>xrf_uploader</code> and upload the firmware to the newly connected XRF module:</p>

<p><code>sh
./xrf_uploader -d /dev/ttyAMA0 -f llapThermistor-V0.73-24MHz.bin
</code></p>

<p>Note: <code>/dev/ttyAMA0</code> is the Raspberry Pi&rsquo;s location of the <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a>.</p>

<p>The upload should look something like this:</p>

<p>``` sh
pi@raspberrypi ~/xrf_loader $ ./xrf_uploader -d /dev/ttyAMA0 -f llapThermistor-V0.73-24MHz.bin
Writing new firmware file llapThermistor-V0.50-24MHz.bin to device /dev/ttyAMA0 with baud rate 9600&hellip;
Reading firmware file&hellip;
Read 1300 lines from firmware file
Opening device&hellip;
Setting serial parameters&hellip;
Waiting for device to settle&hellip;</p>

<p>&lt;> Entering command modus
&lt;&ndash; OK
&ndash;> ATVR
&lt;&ndash; 0.63B XRF
&lt;&ndash; OK
&ndash;> ATPG
&lt;&ndash; OK
&lt;> Sent 1300 of 1300 lines&hellip;</p>

<p>All OK, XRF successfully reprogrammed!</p>

<p>Waiting for device to settle&hellip;</p>

<p>&lt;> Entering command modus
&lt;&ndash; OK
&ndash;> ATVR
&lt;&ndash; 0.50B APTHERM
&lt;&ndash; OK
```</p>

<ul>
<li>Shutdown the Raspberry Pi</li>
<li>Detach the freshly configured XRF &lsquo;sensor&rsquo; module and replace it with the XRF module which will be receiving temperature information (this XRF module is called the &lsquo;pass-through&rsquo;).</li>
<li>Connect the the &lsquo;sensor&rsquo; XRF module used for temperature measurement with thermistor board.</li>
<li>Do not insert the battery yet!</li>
<li>Start the Raspberry Pi again.</li>
</ul>


<h3>Configure sensors (XRF modules)</h3>

<p>We now have</p>

<ul>
<li>fully equipped sensor(s) without battery power</li>
<li>Raspberry Pi with receiving sensor</li>
</ul>


<p>Again: Do not insert batteries into the sensors yet.</p>

<p>We first have to install a protocol to communicate between the &lsquo;sensor&rsquo; and the &lsquo;pass-through&rsquo; (aka &lsquo;receiving&rsquo;) XRF device.</p>

<p>Download <a href="http://sourceforge.net/projects/pyserial/files/pyserial/2.5/pyserial-2.5.tar.gz/download">pySerial</a> to the Raspberry Pi.</p>

<p>Unpack and install pySerial:
<code>sh
$ tar xvzf pyserial-2.5.tar.gz
$ cd pyserial-2.5
$ sudo python setup.py install
</code></p>

<h4>Using pySerial/miniterm</h4>

<p>pySerial comes with <code>miniterm.py</code>, a small serial terminal. Attach to the terminal:
<code>sh
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
</code></p>

<p>Press Ctrl+T, followed by Ctrl+E to enable the echo area. This helps during debugging.</p>

<p>Note: The terminal is not intended for <em>typing</em> commands: Always <em>paste</em> the commands from somewhere else.</p>

<p>Note: Once the battery is inserted it will drain very quickly during debugging. Ensure to unplug the battery if it&rsquo;s not needed.</p>

<h5>miniterm: First contact</h5>

<p>While miniterm is running, insert the battery. The output should look something like this:
<code>
a--STARTED--a--STARTED--a--STARTED--a--STARTED--a--STARTED--a--STARTED--
</code></p>

<p>What we are seeing is an example of LLAP (Ciseco&rsquo;s lightweight local automation protocol). A complete documentation of the protocol can be found <a href="http://openmicros.org/index.php/articles/85-llap-lightweight-local-automation-protocol/112-llap">here</a> and <a href="http://openmicros.org/index.php/articles/85-llap-lightweight-local-automation-protocol/297-llap-reference">here</a>.</p>

<p>From Ciseco&rsquo;s documentation:
```
The message structure</p>

<p>[&hellip;] the message is 12 characters long and in 3 distinct sections. To illustrate the 3 separate parts to the message, see this example:</p>

<p>aXXDDDDDDDD
1.     &ldquo;a&rdquo; is lower case and shows the start of the message</p>

<ol>
<li><p>   XX is the device identifier (address A-Z &amp; A-Z)</p></li>
<li><pre><code>DDDDDDDDDD is the data being exchanged.
</code></pre></li>
</ol>


<p>Note: Only the first &ldquo;a&rdquo; character is lowercase, the remaining message always uses uppercase.
```</p>

<p>Paste <code>a--HELLO----</code> into the miniterm. In case your wondering: The default identifier is <code>--</code>. We&rsquo;ll change that later.</p>

<p><code>sh
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
--- Miniterm on /dev/ttyAMA0: 9600,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
--- local echo active ---
a--HELLO----
</code></p>

<p>If the remote device is running and configured correctly the output should immediatly change to:
<code>sh
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
--- Miniterm on /dev/ttyAMA0: 9600,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
--- local echo active ---
a--HELLO----a--HELLO----
</code></p>

<p>Note the duplicate <code>a--HELLO----</code> in the last line. The second <code>a--HELLO----</code> is the answer from the remote device.</p>

<h5>miniterm: Change device ID</h5>

<p>Since all devices have the same initial ID, it is a good idea to change the device ID in case you intend to use more than one remote device.</p>

<p>The following code changes the device ID to <code>ZZ</code>:
<code>
a--CHDEVIDZZ
a--REBOOT---
</code></p>

<p>The terminal output should look like this:
<code>
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
--- Miniterm on /dev/ttyAMA0: 9600,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
--- local echo active ---
a--CHDEVIDZZ
a--REBOOT---aZZSTARTED--aZZSTARTED--aZZSTARTED--aZZSTARTED--aZZSTARTED--aZZSTARTED--
</code></p>

<h5>miniterm: Read temperature</h5>

<p>Assuming the device ID is <code>ZZ</code> reading the temperature is accomplished by <code>aZZTEMP-----</code>:
<code>
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
--- Miniterm on /dev/ttyAMA0: 9600,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
--- local echo active ---
aZZTEMP-----aZZTMPA24.21
</code></p>

<p>In the above answer from the remote device the temperature is 24.21 degrees Celsius.</p>

<h5>miniterm: Configure measurement interval</h5>

<p>Currently the remote device is contiously sending information. And draining the battery. To preserve battery power the interval can be configured to send information periodically using the command <code>a--INTVL</code>. The interval is defined with a 3 digit number followed by the time period: S(seconds), M(minutes), H(hours), D(days). For example the command <code>aZZINTVL005S</code> would set the interval of the remote device to 5 seconds.</p>

<p>Additionally the device should be sent to sleep in between cylces by issuing the command <code>aZZCYCLE----</code>:
<code>
$ python ~/pyserial-2.5/examples/miniterm.py /dev/ttyAMA0
--- Miniterm on /dev/ttyAMA0: 9600,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
--- local echo active ---
aZZINTVL001H
aZZCYCLE----
</code></p>

<p>The above example sets the interval to one hour (<code>001H</code>).</p>

<p>Repeat the sensor setup and configuration for each sensor which needs to send data. The &lsquo;pass-through&rsquo; (aka receiving) sensor does not have to be configured.</p>

<p>Part 2 will describe a simple program to monitor the data being produced by this setup.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remotly measuring temperatures with a Raspberry Pi using radio frequency modules from Ciseco (Part 2: Software)]]></title>
    <link href="http://draptik.github.io/blog/2015/07/10/remotly-measuring-temperatures-with-a-raspberry-pi-using-radio-frequency-modules-from-ciseco-part-2-software/"/>
    <updated>2015-07-10T00:03:12+02:00</updated>
    <id>http://draptik.github.io/blog/2015/07/10/remotly-measuring-temperatures-with-a-raspberry-pi-using-radio-frequency-modules-from-ciseco-part-2-software</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2015/07/10/remotly-measuring-temperatures-with-a-raspberry-pi-using-radio-frequency-modules-from-ciseco-part-1-hardware/">previous post</a> I described how to setup the hardware for measuring temperatures at home.
This post will use a small python program to save the recorded temperatures to a database.</p>

<p>For simplicity&rsquo;s sake we&rsquo;ll be using SQLite3 as our database.</p>

<p>Aside from our (indoor) temperature sensors, we&rsquo;ll also retrieve outdoor temperatures using the free service <a href="http://www.wunderground.com/">weather underground</a> (registration required).</p>

<p>Note: In case your Raspberry Pi does not have access to the internet you can just exlude the weather underground parts in the code below.</p>

<p>All following code is intended to run on the Raspberry Pi receiving the data.</p>

<h3>Create database (SQLite3)</h3>

<p>The database schema is simple. We need one table to store the temperatures, and another to store sensor information.</p>

<p>Create a new file called <code>templog.db</code>:</p>

<p><code>sh
$ touch templog.db
</code></p>

<p>There are different ways to interact with SQLite3 (cli (=interactive), script, api).</p>

<p>The goal is to execute the following sql statements:</p>

<p>``` sql
CREATE TABLE sensors
(</p>

<pre><code>name TEXT NOT NULL,
id TEXT NOT NULL,
baudrate INTEGER,
port TEXT NOT NULL,
active INTEGER
</code></pre>

<p>);
CREATE TABLE temps
(</p>

<pre><code>timestamp TEXT,
temp REAL,
ID TEXT
</code></pre>

<p>);
<code>``
Simplest solution is to open the newly created file</code>templog.db<code>with</code>sqlite3` (cli/interactive) &hellip;</p>

<p><code>
sqlite3 templog.db
</code>
&hellip;and past the previous code block. Should look like this:</p>

<p><code>
$ sqlite3 demo.db
SQLite version 3.8.10.2 2015-05-20 18:17:19
Enter ".help" for usage hints.
sqlite&gt; CREATE TABLE sensors
   ...&gt; (
   ...&gt;     name TEXT NOT NULL,
   ...&gt;     id TEXT NOT NULL,
   ...&gt;     baudrate INTEGER,
   ...&gt;     port TEXT NOT NULL,
   ...&gt;     active INTEGER
   ...&gt; );
sqlite&gt; CREATE TABLE temps
   ...&gt; (
   ...&gt;     timestamp TEXT,
   ...&gt;     temp REAL,
   ...&gt;     ID TEXT
   ...&gt; );
</code></p>

<p>We&rsquo;ve created a database.</p>

<p>The important table is <code>temps</code>: It will contain the measurements.</p>

<p>The other table (<code>sensors</code>) contains informations about the sensors, which are currently only needed for the weather underground &lsquo;sensor&rsquo;. And yes: the column names/types are not optimal.</p>

<p>Note: <code>timestamp TEXT</code> will bite us in the ass, but SQLite3 does NOT have any date type.</p>

<h3>Monitor script</h3>

<p>I found this nice script somewhere on <a href="https://github.com/kal001/temperature">Github</a>. So Thank You <a href="https://github.com/kal001">kal001</a>!</p>

<p>Here&rsquo;s my <a href="https://gist.github.com/draptik/36834b68b7b4d6366f38">gist link for the script below</a>.</p>

<p>Place this script side-by-side to <code>temps.log</code>.</p>

<p>Save it as <code>monitor.py</code>.</p>

<p>You will probably want to modify the values for <code>dbname</code>, <code>TIMEOUT</code>, <code>debug.txt</code>, etc.</p>

<p>``` python</p>

<h1>!/usr/bin/env python</h1>

<p>import sqlite3
import threading
from time import time, sleep, gmtime, strftime</p>

<p>import serial
import requests</p>

<h1>global variales</h1>

<h1>sqlite database location</h1>

<p>dbname = &lsquo;templog.db&rsquo;</p>

<h1>serial device</h1>

<p>DEVICE = &lsquo;/dev/ttyAMA0&rsquo;
BAUD = 9600</p>

<p>ser = serial.Serial(DEVICE, BAUD)</p>

<h1>timeout in seconds for waiting to read temperature from sensors</h1>

<p>TIMEOUT = 30</p>

<h1>weather underground data</h1>

<p>WUKEY = &lsquo;&rsquo;
STATION = &lsquo;&rsquo;</p>

<h1>time between weather underground samples in seconds</h1>

<p>SAMPLE = 30 * 60</p>

<p>def log_temperature(temp):</p>

<pre><code>"""
Store the temperature in the database.
"""

conn = sqlite3.connect(dbname)
curs = conn.cursor()

curs.execute("INSERT INTO temps values(datetime('now', 'localtime'), '{0}', '{1}' )".format(temp['temperature'], temp['id']))

conn.commit()
conn.close()
</code></pre>

<p>def get_temp():</p>

<pre><code>"""
Retrieves the temperature from the sensor.

Returns -100 on error, or the temperature as a float.
"""

global ser

tempvalue = -100
deviceid = '??'
voltage = 0

fim = time() + TIMEOUT

while (time() &lt; fim) and (tempvalue == -100):
    n = ser.inWaiting()
    if n != 0:
        data = ser.read(n)
        nb_msg = len(data) / 12
        for i in range(0, nb_msg):
            msg = data[i*12:(i+1)*12]
            deviceid = msg[1:3]

            if msg[3:7] == "TMPA":
                tempvalue = msg[7:]

            if msg[3:7] == "BATT":
                voltage = msg[7:11]
                if voltage == "LOW":
                    voltage = 0
    else:
        sleep(5)

return {'temperature':tempvalue, 'id':deviceid}
</code></pre>

<p>def get_temp_wu():</p>

<pre><code>"""
Retrieves temperature(s) from weather underground (wu) and stores it to the database
"""

try:
    conn = sqlite3.connect(dbname)
    curs = conn.cursor()
    query = "SELECT baudrate, port, id, active FROM sensors WHERE id like 'W_'"

    curs.execute(query)
    rows = curs.fetchall()

    #print(rows)

    conn.close()

    if rows != None:
        for row in rows[:]:
            WUKEY = row[1]
            STATION = row[0]

            if int(row[3]) &gt; 0:
                try:
                    url = "http://api.wunderground.com/api/{0}/conditions/q/{1}.json".format(WUKEY, STATION)
                    r = requests.get(url)
                    data = r.json()
                    log_temperature({'temperature': data['current_observation']['temp_c'], 'id': row[2]})
                except Exception as e:
                    raise

except Exception as e:
    text_file = open("debug.txt", "a+")
    text_file.write("{0} ERROR:\n{1}\n".format(strftime("%Y-%m-%d %H:%M:%S", gmtime()), str(e)))
    text_file.close()
</code></pre>

<p>def main():</p>

<pre><code>"""
Program starts here.
"""

get_temp_wu()
t = threading.Timer(SAMPLE, get_temp_wu)
t.start()

while True:
    temperature = get_temp()

    if temperature['temperature'] != -100:
        log_temperature(temperature)

    if t.is_alive() == False:
        t = threading.Timer(SAMPLE, get_temp_wu)
        t.start()
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<p>Run the script. Open another shell, take a look inside the database (new data arriving once an hour?).</p>

<p>Don&rsquo;t forget to start the script after turning off the Raspberry Pi. Or include the script in your boot process (init, systemd).</p>

<p>Part 3 will provide a UI for the collected data.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installing Seafile on Raspberry Pi]]></title>
    <link href="http://draptik.github.io/blog/2014/04/21/installing-seafile-on-raspberry-pi/"/>
    <updated>2014-04-21T00:23:00+02:00</updated>
    <id>http://draptik.github.io/blog/2014/04/21/installing-seafile-on-raspberry-pi</id>
    <content type="html"><![CDATA[<p>With all the security issues in the past relating to privacy I&rsquo;ve been wanting to install a private cloud service similar to <a href="http://www.dropbox.com">Dropbox</a> for some time now. So, here&rsquo;s a post on how to install Seafile on the Raspberry Pi.</p>

<p>I choose <a href="http://seafile.com/en/home/">Seafile</a> over <a href="http://owncloud.org/">Owncloud</a> because I have read multiple posts that (1) Owncloud is not very responsive an a Raspberry Pi and (2) Seafile has a better security model (see <a href="http://blog.kovah.de/private-cloud-owncloud-alternativen-teil-2">1</a>, <a href="http://stevenhickson.blogspot.de/2013/04/cloud-storage-on-raspberry-pi.html">2</a>, <a href="http://stevenhickson.blogspot.de/2013/04/cloud-storage-on-raspberry-pi.html">3</a>).</p>

<p>Using a <a href="http://www.raspberrypi.org">Raspberry Pi</a> for the server seems like a good choice, because it has very low power consumption, so you can have it running 24/7. Furthermore, the Rasperry Pi can be setup with Debian GNU/Linux (f. ex. <a href="http://www.raspbian.org">Raspbian</a>) running in server mode. As Debian is a widely used Linux distribution, most problems can be easily solved by searching the web.</p>

<p>Installing Seafile should be straightforward from following the instructions at the official <a href="https://github.com/haiwen/seafile/wiki/Download-and-setup-seafile-server">Seafile Wiki</a>. If you can read German, you can also follow the excellent instructions on Jan Karres&rsquo;s blog <a href="http://jankarres.de/2013/06/raspberry-pi-owncloud-alternative-seafile-server-installieren/">Raspberry Pi: Owncloud-Alternative Seafile Server installieren</a>.</p>

<p>As there are some pitfalls along the way, I&rsquo;ll describe how I installed Seafile with SSL support.</p>

<h2>Installation</h2>

<p>Note: This is mainly a merge of <a href="http://jankarres.de/2013/06/raspberry-pi-owncloud-alternative-seafile-server-installieren/">Jan Karres&rsquo;s blog post (in German)</a> and the <a href="https://github.com/haiwen/seafile/wiki/Download-and-setup-seafile-server">official wiki documentation from Seafile</a>.</p>

<h3>Demo values</h3>

<p><code>
domain: no-ip.org
sub-domain: mycloud
DDNS-domain: mycloud.no-ip.org
internal server name: mycloud
internal IP address of Raspberry Pi: 192.168.1.42
</code></p>

<h3>Prerequisites</h3>

<p>I&rsquo;ll assume you have a working Raspian installation on a Raspberry Pi.</p>

<p>If you want to reach your Seafile server from the internet and your ISP only provides you with a dynamic IP you will have to register with a <a href="http://en.wikipedia.org/wiki/Dynamic_DNS">DDNS</a> provider such as <a href="http://dyn.com/dns/">Dyn</a> or <a href="http://www.noip.com/">no-ip.com</a>.</p>

<h3>Step 0 Update</h3>

<p>Update Raspbian:</p>

<p><code>$ sudo aptitude update</code></p>

<h3>Step 1 Install dependencies</h3>

<p>Install dependencies required by Seafile:</p>

<p><code>$ sudo aptitude -y install python2.7 python-setuptools python-simplejson python-imaging sqlite3</code></p>

<h3>Step 2 Create seafile user</h3>

<p>For security reasons we&rsquo;ll create a separate user for running Seafile. The user will be called <code>seafile</code> and will not require a password, since we will never be accessing this user directly through SSH.</p>

<p><code>$ sudo adduser seafile --disabled-password</code></p>

<p>Switch to being <code>seafile</code> user:</p>

<p><code>$ sudo su seafile</code></p>

<p>Change to <code>seafile</code>&rsquo;s home directory:</p>

<p><code>$ cd</code></p>

<h3>Step 3 Download and unpack</h3>

<p>First we&rsquo;ll create a new folder <code>mycloud</code> in the seafile user&rsquo;s home directory:</p>

<p><code>$ mkdir mycloud &amp;&amp; cd mycloud</code></p>

<p>Download and unpack Seafile Server for Raspberry Pi from <a href="http://www.seafile.com/en/download/">http://www.seafile.com/en/download/</a>.</p>

<p><code>sh
wget https://bitbucket.org/haiwen/seafile/downloads/seafile-server_2.1.5_pi.tar.gz
tar -xvzf seafile-server_*
mkdir installed
mv seafile-server_* installed
</code></p>

<p>You should have the following directory structure:</p>

<p>``` sh
tree /home/seafile/mycloud/ -L 2
/home/seafile/mycloud/
├── installed
│   └── seafile-server_2.1.5_pi.tar.gz
└── seafile-server-2.1.5</p>

<pre><code>├── reset-admin.sh
├── runtime
├── seaf-fuse.sh
├── seafile
├── seafile.sh
├── seahub
├── seahub.sh
├── setup-seafile-mysql.py
├── setup-seafile-mysql.sh
├── setup-seafile.sh
└── upgrade
</code></pre>

<p>```</p>

<p>All config files are in the folder <code>mycloud</code> (currently there are no config files present yet).
New versions can be installed side by side without having to change the config files. The install process will create a soft link <code>seafile-server-latest</code> pointing the the most current installation.</p>

<h3>Step 4 Installation</h3>

<p><code>$ cd seafile-server-2.1.5</code></p>

<p>Before you start the install process you can have a look at the options being configured during installation <a href="https://github.com/haiwen/seafile/wiki/Download-and-setup-seafile-server#SSetup">here</a>.</p>

<p>For this example we&rsquo;ll assume your DDNS domain is <code>mycloud.no-ip.org</code> and that we&rsquo;ll use the default location for storing our data.
Furthermore, we&rsquo;ll use <code>mycloud</code> as our server name.</p>

<p>During the installation of Seahub (the web frontend for the Seafile server) you must enter an admin email address and provide a password (this password is your Seafile admin password and should not be the same as your email account password).</p>

<p>All other question can be answered by using the default values (press ENTER).</p>

<p><code>./setup-seafile.sh</code></p>

<p>Your directory tree should now look something like this:</p>

<p><code>sh
tree . -L 2
.
├── ccnet # &lt;--------------------------- configuration files
│   ├── ccnet.conf
│   ├── ccnet.conf.lan
│   ├── ccnet.conf.wan
│   ├── ccnet.db
│   ├── GroupMgr
│   ├── misc
│   ├── mykey.peer
│   ├── OrgMgr
│   ├── PeerMgr
│   └── seafile.ini
├── conf
│   └── seafdav.conf
├── installed
│   └── seafile-server_2.1.5_pi.tar.gz
├── logs
│   ├── ccnet.log
│   ├── controller.log
│   ├── http.log
│   ├── seafile.log
│   ├── seahub_django_request.log
│   └── seahub.log
├── seafile-server-2.1.5
│   ├── reset-admin.sh
│   ├── runtime
│   ├── seaf-fuse.sh
│   ├── seafile
│   ├── seafile.sh
│   ├── seahub
│   ├── seahub.sh
│   ├── setup-seafile-mysql.py
│   ├── setup-seafile-mysql.sh
│   ├── setup-seafile.sh
│   └── upgrade
├── seafile-server-latest -&gt; seafile-server-2.1.5
├── seahub-data
│   └── avatars
├── seahub.db
├── seahub_settings.py
└── seahub_settings.pyc
</code></p>

<h3>Step 5 Update URLs for Seahub</h3>

<p><code>nano /home/seafile/mycloud/ccnet/ccnet.conf</code></p>

<p><code>sh /home/seafile/mycloud/ccnet/ccnet.conf
SERVICE_URL = https://mycloud.no-ip.org:8001
</code></p>

<p>Don&rsquo;t forget replacing <code>http</code> with <code>https</code>&hellip;</p>

<p>Also add a line to <code>seahub_settings.py</code>.</p>

<p><code>nano /home/seafile/mycloud/seahub_settings.py</code></p>

<p><code>sh /home/seafile/mycloud/seahub_settings.py
SECRET_KEY ...
HTTP_SERVER_ROOT = 'https://mycloud.no-ip.org:8001/seafhttp'
</code></p>

<h3>Step 6 (Re)start Seahub in FastCGI mode</h3>

<p><code>/home/seafile/mycloud/seafile-server-latest/seahub.sh stop</code></p>

<p><code>/home/seafile/mycloud/seafile-server-latest/seahub.sh start-fastcgi</code></p>

<h3>Step 7 Install nginx (as admin)</h3>

<p>IMPORTANT: Do not run steps 7 to 11 as user <code>seafile</code>. Use the default <code>pi</code> user for admin stuff.</p>

<p><code>sudo aptitude install nginx</code></p>

<p>Patching nginx for Raspberry Pi:
<code>sh
sudo sed -i "s/worker_processes 4;/worker_processes 1;/g" /etc/nginx/nginx.conf
sudo sed -i "s/worker_connections 768;/worker_connections 128;/g" /etc/nginx/nginx.conf
sudo /etc/init.d/nginx start
</code></p>

<h3>Step 8 Create a self certified SSL certificate (as admin)</h3>

<p>The following commands create a self certified SSL certificate. The second to last command is interactive and will ask a few questions. Provide <em>Country Name</em> (enter your two letter country code, i.e. DE for Germany, UK for United Kingdom) and <em>Common Name</em>. The later should be your DDNS name (<code>mycloud.no-ip.org</code> in this example).</p>

<p><code>sh
sudo mkdir /etc/nginx/ssl
cd /etc/nginx/ssl
sudo openssl genrsa -out seahub.key 2048
sudo openssl req -new -key seahub.key -out seahub.csr
sudo openssl x509 -req -days 3650 -in seahub.csr -signkey seahub.key -out seahub.crt
</code></p>

<h3>Step 9 Create nginx Seahub site (as admin)</h3>

<p><code>sudo nano /etc/nginx/sites-available/seahub</code></p>

<p>``` sh /etc/nginx/sites-available/seahub
server {</p>

<pre><code>listen 8001; # &lt;--------------------------------------- NGINX PORT
ssl on; # &lt;-------------------------------------------- SSL
ssl_certificate /etc/nginx/ssl/seahub.crt; # &lt;--------- SSL
ssl_certificate_key /etc/nginx/ssl/seahub.key; # &lt;----- SSL
server_name mycloud.no-ip.org.tld; # &lt;----------------- CHANGE THIS
error_page 497  https://$host:$server_port$request_uri;

location / {
    fastcgi_pass    127.0.0.1:8000;
    fastcgi_param   SCRIPT_FILENAME     $document_root$fastcgi_script_name;
    fastcgi_param   PATH_INFO           $fastcgi_script_name;

    fastcgi_param   SERVER_PROTOCOL $server_protocol;
    fastcgi_param   QUERY_STRING        $query_string;
    fastcgi_param   REQUEST_METHOD      $request_method;
    fastcgi_param   CONTENT_TYPE        $content_type;
    fastcgi_param   CONTENT_LENGTH      $content_length;
    fastcgi_param   SERVER_ADDR         $server_addr;
    fastcgi_param   SERVER_PORT         $server_port;
    fastcgi_param   SERVER_NAME         $server_name;
    fastcgi_param   HTTPS   on;
    fastcgi_param HTTP_SCHEME https;

    access_log      /var/log/nginx/seahub.access.log;
    error_log       /var/log/nginx/seahub.error.log;
}       
location /seafhttp {
    rewrite ^/seafhttp(.*)$ $1 break;
    proxy_pass http://127.0.0.1:8082;
    client_max_body_size 0;
}

location /media {
    root /home/seafile/mycloud/seafile-server-latest/seahub; # &lt;-- change: 2014-07-11
    # include /etc/nginx/mime.types; # &lt;--- UNCOMMENT THIS IF CSS FILES AREN'T LOADED
}
</code></pre>

<p>}
```</p>

<h3>Step 10 Activate nginx Seahub site (as admin)</h3>

<p><code>sudo ln -s /etc/nginx/sites-available/seahub /etc/nginx/sites-enabled/seahub</code></p>

<h3>Step 11 Restart nginx (as admin)</h3>

<p><code>sudo /etc/init.d/nginx restart</code></p>

<h3>Step 12 Network: Setup port forwarding</h3>

<p>Depending on your router, the naming might differ. Some routers call it &ldquo;port mapping&rdquo;, some call it &ldquo;port forwarding&rdquo;. For what we are doing, it&rsquo;s all the same.</p>

<p>My ISP provided me with a combined dsl-modem/router called &ldquo;Easybox 904 xDSL&rdquo;, so YMMV:</p>

<p><img class="center" src="/images/posts/seafile_rpi/router_portmapping.png"></p>

<h3>Step 13 Test if everything works</h3>

<h4>LAN test using IP address</h4>

<p>Test if Seafile/Seahub is reachable from within your LAN using the <em>IP address</em> of your Raspberry Pi. Assuming the Raspberry Pi has the internal IP address 192.168.1.42, entering <code>https://192.168.1.42:8001</code> in your browser should render the Seahub page.</p>

<p>If this fails, go back and confirm that you don&rsquo;t have any typos in your config files.</p>

<h4>Internet test</h4>

<p>Test if Seafile/Seahub is reachable from the <em>internet</em>. You must use a device which is not connected to your LAN. If you have a smartphone, you can deactivate your WiFi, and try connecting to your newly setup server at <code>https://mycloud.no-ip.org:8001</code>. The Seahub page should be rendered correctly in your &lsquo;internet&rsquo; browser.</p>

<p>If this fails, go back and confirm that you don&rsquo;t have any typos in your config files.</p>

<h4>LAN test using DDNS</h4>

<p>Try connecting to Seafile/Seahub from within the LAN using the DDNS name: <code>https://mycloud.no-ip.org:8001</code>.</p>

<p>If this works out of the box, you can skip the rest of this article.</p>

<h3>Step 14</h3>

<p>I should probably mention that I am not a trained network admin. So everything below falls under the category &ldquo;works for my setup, sorry I can&rsquo;t provide support&rdquo;.</p>

<p>Here&rsquo;s an image of what has to be accomplished:</p>

<p><img class="center" src="/images/posts/seafile_rpi/nat-loopback.svg"></p>

<h3>Step 14a NAT loopback</h3>

<p>If trying to reach the IP of your DDNS from within your LAN fails, you should try to setup your NAT loopback (see your router documentation for details).</p>

<h3>Step 14b Workaround, in case NAT loopback doesn&rsquo;t work</h3>

<p>This is the tricky part. (Marko, thanks!)</p>

<p><em>BEWARE: This works with my setup, but it might ruin your setup.</em></p>

<ol>
<li><p>Rename internal LAN DNS zone to <code>no-ip.org</code> (replace with your domain)</p>

<p> <img class="center" src="/images/posts/seafile_rpi/router_rename_wan_domain.png" title="&lsquo;Rename internal LAN DNS zone&rsquo;" ></p></li>
<li><p>Rename internal LAN name (static DHCP lease) to <code>mycloud</code> (replace with your sub domain)</p>

<p> <img class="center" src="/images/posts/seafile_rpi/router_dhcp_static_leases.png" title="&lsquo;Rename internal LAN name&rsquo;" ></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up a network printer using Raspberry Pi]]></title>
    <link href="http://draptik.github.io/blog/2013/05/30/setting-up-a-network-printer-using-raspberry-pi/"/>
    <updated>2013-05-30T08:30:00+02:00</updated>
    <id>http://draptik.github.io/blog/2013/05/30/setting-up-a-network-printer-using-raspberry-pi</id>
    <content type="html"><![CDATA[<p><a href="http://www.lynsayshepherd.com/blog/?p=1340">This post by Lynsay</a> describes in detail how to convert a non-network printer into a network printer.</p>

<p>You will have to install CUPS and SAMBA on your Raspberry Pi.</p>

<p>Once your done you can access the printer from any OS (windows, linux, mac) within your network.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RPi/XBMC: Keeping content in sync]]></title>
    <link href="http://draptik.github.io/blog/2013/05/25/rpi-xbmc-sync/"/>
    <updated>2013-05-25T19:24:00+02:00</updated>
    <id>http://draptik.github.io/blog/2013/05/25/rpi-xbmc-sync</id>
    <content type="html"><![CDATA[<p>If you have multiple <a href="http://www.raspberrypi.org/">Rasperry Pi</a>/<a href="http://xbmc.org/">XBMC</a> clients and want to</p>

<ul>
<li>keep your &ldquo;history&rdquo; in sync (watch a movie in room1, stop, start the same movie in room2 and resume)</li>
<li>do not want to individually update every RPi/XBMC client if the content of your data storage changes</li>
</ul>


<p>then this post might be for you.</p>

<p><a href="http://wiki.xbmc.org/index.php?title=HOW-TO:Share_libraries_using_MySQL">The XBMC Wiki decribes this in detail</a>.
This post just describes an actual implementation using Raspberry Pi clients and server.</p>

<p>To do this you will need a MySQL database on a machine in your network which is always accessible from your Raspberry Pi/XBMC clients (called <code>RPI-Client</code> from now on).
Since I didn&rsquo;t have a machine like this in my network I decided to buy another RPi for this purpose (referred to as <code>RPi-Server</code> from now on).</p>

<p><strong>The content of the MySQL database only contains metadata for each entry, not the actual data</strong> (information like (a) the file path and (b) the last timestamp within the movie you were watching).</p>

<p>Here is a diagram showing my network setup for two Rasperry Pi clients running XBMC:</p>

<p><code>sh network
+---+
|   |   |---------------------------------|
|   |---| RPi-Client-1 (XBMC living room) |
|   |   |---------------------------------|
|   |
| L |   |------------------------------|
| A |---| RPi-Client-2 (XBMC bed room) |
| N |   |------------------------------|
|   |
|   |   |-----------------------|
|   |---| RPi-Server (Raspbian) |
|   |   |-----------------------|
|   |
|   |   |-----|
|   |---| NAS |
|   |   |-----|
+---+
</code></p>

<ul>
<li>The clients <code>RPi-Client-X</code> are default <a href="http://openelec.tv/">OpenELEC</a> installations.</li>
<li>The server <code>RPi-Server</code> is a default <a href="http://www.raspbian.org/">Raspbian</a> installation.</li>
</ul>


<h2>RPi-Server Setup</h2>

<p>The <code>RPi-Server</code> has to provide a MySQL database which can be accessed from each <code>RPi-Client-X</code>.
Just follow the <a href="http://wiki.xbmc.org/index.php?title=HOW-TO:Share_libraries_using_MySQL/Setting_up_MySQL">simple setup instructions on the XBMC-Wiki</a>.</p>

<p>This is how you can check the status of your MySQL server:</p>

<p><code>
rpi-server$ sudo /etc/init.d/mysql status
</code></p>

<h2>RPi-Client Setup</h2>

<p>Each <code>RPi-Client-X</code> needs to be configured to use the <code>RPi-Server</code> database.</p>

<p><code>RPi-Server: 192.168.179.36</code></p>

<p>``` xml advancedsettings.xml
<advancedsettings>
  <videodatabase></p>

<pre><code>    &lt;type&gt;mysql&lt;/type&gt;
    &lt;host&gt;192.168.179.36&lt;/host&gt;
    &lt;port&gt;3306&lt;/port&gt;
    &lt;user&gt;xbmc&lt;/user&gt;
    &lt;pass&gt;xbmc&lt;/pass&gt;
</code></pre>

<p>  </videodatabase>
  <musicdatabase></p>

<pre><code>    &lt;type&gt;mysql&lt;/type&gt;
    &lt;host&gt;192.168.179.36&lt;/host&gt;
    &lt;port&gt;3306&lt;/port&gt;
    &lt;user&gt;xbmc&lt;/user&gt;
    &lt;pass&gt;xbmc&lt;/pass&gt;
</code></pre>

<p>  </musicdatabase>
</advancedsettings>
```</p>

<p>Note:
The location of the file <code>advancedsettings.xml</code> might very depending on your XBMC installation.
For OpenELEC the file is located at <code>/storage/.xbmc/userdata/advancedsettings.xml</code>.</p>

<h2>XBMC Library Update (optional)</h2>

<p>Once the above setup works you can install the <a href="http://wiki.xbmc.org/index.php?title=Add-on:XBMC_Library_Auto_Update">XBMC Addon:Library Auto Update</a>.
This plugin provides a GUI to setup a cron job to sync the content your <code>RPi-Client-X</code> has acces to (i.e. your NAS) with your MySQL database.
Just install it on <em>one</em> of your <code>RPi-Client-X</code>.</p>

<h2>MySQL Backup (optional)</h2>

<p>A bit overkill, but I also backup the MySQL Database from the <code>RPi-Server</code> to my NAS using <a href="http://sourceforge.net/projects/automysqlbackup/">automysqlbackup</a>.</p>
]]></content>
  </entry>
  
</feed>
