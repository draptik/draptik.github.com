<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fluentassertions | draptik]]></title>
  <link href="http://draptik.github.io/blog/categories/fluentassertions/atom.xml" rel="self"/>
  <link href="http://draptik.github.io/"/>
  <updated>2016-05-11T22:43:40+02:00</updated>
  <id>http://draptik.github.io/</id>
  <author>
    <name><![CDATA[Patrick Drechsler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing that different objects have the same properties]]></title>
    <link href="http://draptik.github.io/blog/2016/05/09/testing-objects-have-same-properties/"/>
    <updated>2016-05-09T19:25:17+02:00</updated>
    <id>http://draptik.github.io/blog/2016/05/09/testing-objects-have-same-properties</id>
    <content type="html"><![CDATA[<p>Sometimes you want to ensure that 2 unrelated objects share a set of properties &mdash; without using an interface.</p>

<p>Here is an example:</p>

<p>``` csharp
namespace Demo
{</p>

<pre><code>public class Customer
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
</code></pre>

<p>}
```
First thought for C# developers: <a href="http://automapper.org/">AutoMapper</a></p>

<p>Let&rsquo;s do that:</p>

<p>``` csharp
using AutoMapper;</p>

<p>namespace Demo
{</p>

<pre><code>public class MyMapping
{
    public static IMapper Mapper;

    public static void Init()
    {
        var cfg = new MapperConfiguration(x =&gt;
        {
            x.CreateMap&lt;Customer, Person&gt;();
        });
        Mapper = cfg.CreateMapper();
    }
}
</code></pre>

<p>}
```</p>

<p>Now we can write a unit test to see if we can convert a Customer to a Person:</p>

<p>``` csharp
using Xunit;</p>

<p>namespace Demo
{</p>

<pre><code>public class SomeTests
{
    [Fact]
    public void Given_Customer_Should_ConvertTo_Person()
    {
        // Arrange
        const string firstname = "foo";
        const string lastname = "bar";

        var customer = new Customer
        {
            FirstName = firstname,
            LastName = lastname
        };

        MyMapping.Init();

        // Act
        var person = MyMapping.Mapper.Map&lt;Customer, Person&gt;(customer);

        // Assert
        person.FirstName.Should().Be(firstname);
        person.LastName.Should().Be(lastname);
    }
}
</code></pre>

<p>} <br/>
```
This test passes.</p>

<p>But what happens when we want to ensure that a new Customer property (for example <code>Email</code>) is reflected in the Person object?</p>

<p>``` csharp
namespace Demo
{</p>

<pre><code>public class Customer
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; } // &lt;-- new property
}

public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
</code></pre>

<p>}
```</p>

<p>Our unit test still passes. &#9785;</p>

<p><strong>Wouldn&rsquo;t it be nice to have our unit test fail if the classes are not in sync?</strong></p>

<p>Here is where <a href="http://www.fluentassertions.com/">FluentAssertions</a> <code>ShouldBeEquivalentTo</code> comes in handy:</p>

<p>``` csharp
using FluentAssertions;
using Xunit;</p>

<p>[Fact]
public void Given_Customer_Should_ConvertTo_Person_With_CurrentProperties()
{</p>

<pre><code>//Arrange
const string firstname = "foo";
const string lastname = "bar";

var customer = new Customer
{
    FirstName = firstname,
    LastName = lastname,
    Email = "foo@bar.com"
};

MyMapping.Init();

// Act
var person = MyMapping.Mapper.Map&lt;Customer, Person&gt;(customer);

// Assert
customer.ShouldBeEquivalentTo(person);
</code></pre>

<p>}
```</p>

<p><img src="/images/posts/dotnet/equivalentto_result.png"></p>

<p><code>Subject has a member  Email that the other object does not have.</code></p>

<p>Cool: This is the kind of message I want to have from a unit test!</p>

<p><code>ShouldBeEquivalentTo</code> also takes an optional Lambda expression in case you need more fine grained control which properties are included in the comparison. Here is an example where we exlude the <code>Email</code> property on purpose:</p>

<p>``` csharp
using FluentAssertions;
using Xunit;</p>

<p>[Fact]
public void Given_Customer_Should_ConvertTo_Person_With_CurrentProperties_Excluding_Email()
{</p>

<pre><code>//Arrange
const string firstname = "foo";
const string lastname = "bar";

var customer = new Customer
{
    FirstName = firstname,
    LastName = lastname,
    Email = "foo@bar.com"
};

MyMapping.Init();

// Act
var person = MyMapping.Mapper.Map&lt;Customer, Person&gt;(customer);

// Assert
customer.ShouldBeEquivalentTo(person,
    options =&gt;
        options.Excluding(x =&gt; x.Email));
</code></pre>

<p>}
```</p>

<p>This test passes.</p>

<p>The complete documentation for FluentAssertions' <code>ShouldBeEquivalentTo</code> method can be found <a href="https://github.com/dennisdoomen/fluentassertions/wiki#object-graph-comparison">here</a>.</p>

<h2>Source code for this post</h2>

<p>You can clone a copy of this project here: <a href="https://github.com/draptik/blog-demo-shouldbeequivalentto">https://github.com/draptik/blog-demo-shouldbeequivalentto</a>.</p>

<p><code>sh
git clone https://github.com/draptik/blog-demo-shouldbeequivalentto.git
</code></p>
]]></content>
  </entry>
  
</feed>
