<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | draptik]]></title>
  <link href="http://draptik.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://draptik.github.io/"/>
  <updated>2019-09-02T21:37:31+00:00</updated>
  <id>http://draptik.github.io/</id>
  <author>
    <name><![CDATA[Patrick Drechsler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Review: Hands-On Domain-Driven Design with .NET Core by Alexey Zimarev]]></title>
    <link href="http://draptik.github.io/blog/2019/06/25/review-hands-on-ddd-dotnetcore/"/>
    <updated>2019-06-25T21:42:37+00:00</updated>
    <id>http://draptik.github.io/blog/2019/06/25/review-hands-on-ddd-dotnetcore</id>
    <content type="html"><![CDATA[<blockquote><p>I have updated this post because the author took the time to respond to my review.</p></blockquote>

<h2>TL;DR</h2>

<p>The book <a href="https://www.packtpub.com/application-development/hands-domain-driven-design-net-core">Hands-On Domain-Driven-Design with .NET Core</a> by Alexey Zimarev illustrates the pros &amp; cons of different CQRS/ES persistency options in the .NET space. I can highly recommend this book to anybody looking for a deep dive into concrete CQRS/ES examples using up-to-date solutions.</p>

<h2>Content</h2>

<p>Although the book title includes &ldquo;Hands-On&rdquo;, people new to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design (DDD)</a> will get a compact and up-to-date introduction to the topic in the first few chapters of the book. I especially enjoyed how the author introduces <a href="https://en.wikipedia.org/wiki/Event_storming">Event Storming</a> as a valuable technique for distilling an <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">Ubiquitous Language</a>.</p>

<p><strong>The book focuses on <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing (ES)</a> and <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation#Command_query_responsibility_segregation">Command Query Responsibility Segregation (CQRS)</a>.</strong> Previous DDD books (especially in the .NET space) have often treated both of these subjects as an implementation detail. Although I must mention that the book <a href="http://www.wrox.com/WileyCDA/WroxTitle/Patterns-Principles-and-Practices-of-Domain-Driven-Design.productCd-1118714709.html">Patterns, Principles and Practices of Domain Driven Design (by Tune &amp; Millet)</a> also provides some excellent hands-on advice on CQRS &amp; ES.</p>

<p>One of the interesting &ldquo;twists&rdquo; of the book is that is does not use the default database most .NET developers are used to: MS-SQL. Instead, the author demonstrates that using the right tool for the job also should get us thinking about using the most appropriate persistence store for architectural patterns such as CQRS and ES.</p>

<p>Since neither an &ldquo;event store&rdquo; (ES) nor a read-model database require &ldquo;relations&rdquo;, relational databases can be dropped in favour of NoSQL solutions. The author introduces the following modern <del>document stores</del> storage solutions (2019-06-30: thx to Alexey for the pointer)</p>

<ul>
<li><a href="https://ravendb.net/">RavenDb</a></li>
<li><a href="https://www.postgresql.org/">PostgreSQL</a></li>
<li><a href="https://eventstore.org/">Event Store</a></li>
</ul>


<p>The pros &amp; cons of each solution are demonstrated elaborately: As reader you get a very good impression of which solution might work for you. I really enjoyed this part, because you can clearly see how leaky abstractions change a core domain. F.ex. which framework/DB can map Value Objects without having to change the visibility of ctors or property-setters&hellip; Or having to introduce an Id property just for persistence&hellip;</p>

<p>The most valuable chapter (for me) in the book is &ldquo;Projections &amp; Queries&rdquo;.</p>

<p>It provides potential solutions for mapping event store &ldquo;events&rdquo; with read model DB entries. This is a &ldquo;best practices&rdquo; chapter full of different approaches on how to keep your read models in sync with your event store. My personal &lsquo;I did not know I could do this&rsquo;-pattern: Event-Upcasting: Neat technique!</p>

<h2>Cons</h2>

<ul>
<li>Black &amp; white print of the book makes viewing the Event Storming images difficult (although the publisher provides color images)</li>
<li>Copy editing could be improved (typos in text and source code)

<ul>
<li><a href="https://twitter.com/Zimareff/status/1144582525467136001">2019-07-02: answer from the author</a> &ldquo;[&hellip;] I can only blame Packt for typos since they told me and reviewers explicitly not to pay attention. [&hellip;]&rdquo;</li>
</ul>
</li>
<li>Technical review

<ul>
<li>Ubiquitous language is suddenly changed (example: <code>ClassifiedAdPublished</code> to <code>ClassifiedAdPublic</code>)

<ul>
<li><a href="https://twitter.com/Zimareff/status/1145450330076975105">2019-07-02: answer from the author</a> &ldquo;[&hellip;] there&rsquo;s a difference between Published (it&rsquo;s a state) and Public (it&rsquo;s a view). Like, a public ad doesn&rsquo;t contain certain private elements (personal data and such). It might not be clear from the code and text, but that was the idea.&rdquo;</li>
</ul>
</li>
<li>Mismatches between text and code samples</li>
</ul>
</li>
<li>The book deals with polyglot persistence, (potentially) distributed systems, and the infamous &ldquo;eventually consistency&rdquo; problems.

<ul>
<li>Some integrations test in the code samples would have been nice (for api, projections, persistence).</li>
<li>Some examples (in the code samples) about monitoring would have been nice.</li>
<li><a href="https://twitter.com/Zimareff/status/1144582807534129153">2019-07-02: answer from the author</a> &ldquo;Concerning the whole distribution, integration, and monitoring &ndash; it exceeds the original scope of the book. Tbh, I have a lot to say there as well, so [&hellip;]&rdquo;</li>
</ul>
</li>
</ul>


<h2>Pros</h2>

<ul>
<li>100% .NET Core: I was able to follow along using Linux &amp; JetBrains Rider / VSCode</li>
<li>Learning about alternative storage solutions and best practices for using them:

<ul>
<li><a href="https://eventstore.org/">Event Store</a></li>
<li><a href="https://ravendb.net/">RavenDb</a></li>
<li><a href="https://www.postgresql.org/">PostgreSQL</a> (with and without Entity Framework)</li>
</ul>
</li>
<li>all persistence demo DBs are provided as easily runnable <code>docker-compose.yml</code> files</li>
<li>libraries and frameworks introduced are very up-to-date</li>
<li>focus on backend: using Swagger as user interface was a great decision</li>
</ul>


<h2>Summary</h2>

<p>It is the first book, to my knowledge, which shows the pros &amp; cons of different CQRS/ES persistency options in the .NET space.</p>

<p>I can highly recommend this book to anybody familiar with DDD and/or wanting to understand concepts such as CQRS/ES. It is also a great addition to <a href="http://www.wrox.com/WileyCDA/WroxTitle/Patterns-Principles-and-Practices-of-Domain-Driven-Design.productCd-1118714709.html">Patterns, Principles and Practices of Domain Driven Design (by Tune &amp; Millet)</a>.</p>

<p>If it were not for the improvable copy editing I would give this book 5 of 5 stars. The second edition will most likely fix this :&ndash;).</p>

<h2>Resources</h2>

<ul>
<li>Official Github Repository: <a href="https://github.com/PacktPublishing/Hands-On-Domain-Driven-Design-with-.NET-Core">https://github.com/PacktPublishing/Hands-On-Domain-Driven-Design-with-.NET-Core</a></li>
<li>My &ldquo;coding along while reading&rdquo; Github repository: <a href="https://github.com/draptik/book_hands-on-domain-driven-design-with-dotnet-core">https://github.com/draptik/book_hands-on-domain-driven-design-with-dotnet-core</a>

<ul>
<li>I tried placing some sensible git tags along the way</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[F# Linux: mixed feelings]]></title>
    <link href="http://draptik.github.io/blog/2018/11/29/fsharp-linux-mixed-feelings/"/>
    <updated>2018-11-29T00:58:33+00:00</updated>
    <id>http://draptik.github.io/blog/2018/11/29/fsharp-linux-mixed-feelings</id>
    <content type="html"><![CDATA[<p>I have been trying to learn F# with .NET Core and Linux for some time. My experience so far are mixed. Let me explain what I mean by &ldquo;mixed&rdquo;:</p>

<p>First off all: It is great that we can use .NET with Linux in the first place! And <code>dotnet</code> as CLI-first tool is amazing (not only for linux desktop users, but also for docker, ci)! I can&rsquo;t emphasis this enough!</p>

<p>BUT:</p>

<ul>
<li>The templates generated by <code>dotnet new</code> are never up-to-date for F#. One always has to spend 30min cleaning up and updating.</li>
<li>IDE integration (Ionide) also takes weeks until everything works flawlessly after a new dotnet core release (VSCode, Rider).</li>
</ul>


<p>Example: Currently (2018-11-29) I have to patch <code>dotnet new xunit -lang f# -o somefolder</code>:</p>

<p>```sh
$ dotnet new xunit -lang f# -o somefolder
The template &ldquo;xUnit Test Project&rdquo; was created successfully.</p>

<p>Processing post-creation actions&hellip;
Running &lsquo;dotnet restore&rsquo; on somefolder/somefolder.fsproj&hellip;
&hellip;
Restore succeeded.
```</p>

<p><code>sh
`$ dotnet test
Build started, please wait...
/home/patrick/.nuget/packages/microsoft.net.test.sdk/15.9.0/build/netcoreapp1.0/Microsoft.Net.Test.Sdk.targets(104,5): warning : A 'Program.fs' file can be automatically generated for F# .NET Core test projects. To fix this warning, either delete the file from the project, or set the &lt;GenerateProgramFile&gt; property to 'false'. [/home/patrick/tmp/somefolder/somefolder.fsproj]
...
</code></p>

<p><strong><em>Why? Learning F#, this really irritates me! Am I doing something wrong? Is it idiomatic to see these kinds of warnings?</em></strong></p>

<p>Fix:</p>

<p><code>sh
cd somefolder
rm Program.fs
sed -i '/Program/d' somefolder.fsproj
</code></p>

<p>Simple, isn&rsquo;t it? F#-Team: Talk to the template team.</p>

<p>Electron apps such as VSCode behave unusually with Arch Linux, so I won&rsquo;t comment on that. And Rider is really slow catching up to new .NET Core versions on Linux&hellip; (linux: 2nd class citizen).</p>

<p>All in all, F# with .NET Core and Linux: keeps being interesting ;&ndash;)</p>

<p>Setup (2018-11-29):</p>

<p>```sh
$ dotnet &mdash;info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.500
 Commit:    b68b931422</p>

<p>Runtime Environment:
 OS Name:     arch
 OS Version:<br/>
 OS Platform: Linux
 RID:         arch-x64
 Base Path:   /opt/dotnet/sdk/2.1.500/</p>

<p>Host (useful for support):
  Version: 2.1.6
  Commit:  3f4f8eebd8</p>

<p>.NET Core SDKs installed:
  2.1.3 [/opt/dotnet/sdk]
  2.1.500 [/opt/dotnet/sdk]</p>

<p>.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.6 [/opt/dotnet/shared/Microsoft.NETCore.App]</p>

<p>To install additional .NET Core runtimes or SDKs:
  <a href="https://aka.ms/dotnet-download">https://aka.ms/dotnet-download</a>
```</p>

<p>Yes, this is just a rant.</p>

<p>I am still a big fan of F#, .NET Core, and Linux. And the combination of the three. I&rsquo;ll keep trying to understand them, because I think they are a good combination.</p>

<p>Any pointers to better usage are more than welcome!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IntelliJ and Gnome keyboard shortcut conflict: Ctrl Alt s]]></title>
    <link href="http://draptik.github.io/blog/2018/08/21/intellij-gnome-keyboard-shortcut-conflict-ctrl-alt-s/"/>
    <updated>2018-08-21T23:01:12+00:00</updated>
    <id>http://draptik.github.io/blog/2018/08/21/intellij-gnome-keyboard-shortcut-conflict-ctrl-alt-s</id>
    <content type="html"><![CDATA[<p>I am currenty experimenting with <a href="https://www.jetbrains.com/rider/">Jetbrains Rider</a> under Linux. Sticking to the default window manager GNOME for my linux distro (Arch Linux), I ran into some problems with conflicting keyboard shortcuts. Even though Jetbrains' IDEs come with a keyboard setting named <code>Default for GNOME</code>&hellip;</p>

<p>Starting with the most obvious: I was not able to open Rider&rsquo;s settings using the keyboard shortcut <code>Ctrl Alt s</code>.</p>

<h2><code>Ctrl Alt s</code></h2>

<p>This command opens the settings in most IntelliJ products (File &ndash;> Settings).</p>

<p>Pressing <code>Crtl Alt s</code> &ldquo;rolled up the window&rdquo;: The current window was minimized to the title bar (an effect I have never seen before and don&rsquo;t need). Double clicking the window title bar expanded the window again. So obviously the keyboard shortcut was already in use. The question being: by which application?</p>

<p>Gnome settings did not reveal any conflicting bindings in the keyboard section!</p>

<p>After some searching the gnome extension <code>screenshot-window-sizer</code> turned out being the culprit. I don&rsquo;t know if I installed this extension on purpose or if it was installed as a dependency by some other package or if belongs to gnome&rsquo;s default. The following solution keeps the extension installed: Only the keyboard shortcut is disabled.</p>

<p>Full name of the extension:</p>

<p><code>org.gnome.shell.extensions.screenshot-window-sizer</code></p>

<p>Here is a short summary how to figure out if your environment is affected by this extension:
``` sh</p>

<h1>Find out if screenshot extension is installed</h1>

<p>gsettings list-schemas | grep screenshot-window-sizer</p>

<h1>List keys</h1>

<p>gsettings list-keys org.gnome.shell.extensions.screenshot-window-sizer
cycle-screenshot-sizes-backward
cycle-screenshot-sizes</p>

<h2>Show key value</h2>

<p>gsettings get org.gnome.shell.extensions.screenshot-window-sizer cycle-screenshot-sizes
[&lsquo;<Alt><Control>s&rsquo;]</p>

<h2>Show key value</h2>

<p>gsettings get org.gnome.shell.extensions.screenshot-window-sizer cycle-screenshot-sizes-backward
[&lsquo;<Shift><Alt><Control>s&rsquo;]
```</p>

<p>The following snippet disables the hijacked <code>Ctrl Alt s</code> binding from <code>screenshot-window-sizer</code> (found <a href="https://extensions.gnome.org/extension/881/screenshot-window-sizer/">here</a>)
``` sh</p>

<h1>disable:</h1>

<p>gsettings set org.gnome.shell.extensions.screenshot-window-sizer cycle-screenshot-sizes []
gsettings reset org.gnome.desktop.wm.keybindings toggle-shaded</p>

<h1>To re-enable:</h1>

<p>gsettings reset org.gnome.shell.extensions.screenshot-window-sizer cycle-screenshot-sizes
gsettings set org.gnome.desktop.wm.keybindings toggle-shaded []
```</p>

<p>Now the keybinding <code>Ctrl Alt s</code> works as expected in IntelliJ products &mdash; even with Gnome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[F# Test Setup for FizzBuzz]]></title>
    <link href="http://draptik.github.io/blog/2018/02/07/fsharp-test-setup-for-fizzbuzz/"/>
    <updated>2018-02-07T20:53:43+00:00</updated>
    <id>http://draptik.github.io/blog/2018/02/07/fsharp-test-setup-for-fizzbuzz</id>
    <content type="html"><![CDATA[<p>In my <a href="http://draptik.github.io/blog/2018/02/05/fsharp-setup-linux-fizzbuzz/">previous post</a> we setup a basic F# project in Linux.</p>

<p>In this post I would like to show how to setup an idiomatic F# testing environment using FsUnit.</p>

<h4>Side note for people unfamiliar with .NET</h4>

<p>Actually, it&rsquo;s not a project, but a &ldquo;solution&rdquo;. To clear things up for people not familiar with the .NET ecosystem: In .NET, the top level configuration is called a &ldquo;solution&rdquo; and resides in a <code>*.sln</code> file. A solution references &ldquo;projects&rdquo;. Each project configuration is stored in a <code>*.fsproj</code> file (F#) or a <code>*.csproj</code> file (C#). Projects can reference each other. This information is stored in the <code>*.[f|c]sproj</code> file.</p>

<p>We have 2 projects (<code>FizzBuzz</code> and <code>FizzBuzz.Tests</code>), each with a <code>*.fsproj</code> file. The <code>FizzBuzz.Tests.fsproj</code> references the <code>FizzBuzz.fsproj</code> file (see the <a href="http://draptik.github.io/blog/2018/02/05/fsharp-setup-linux-fizzbuzz/">previous post</a> for details):
<code>
.
├── FizzBuzz
│   ├── FizzBuzz.fsproj
│   ├── ...
├── FizzBuzz.Tests
│   ├── FizzBuzz.Tests.fsproj
│   ├── ...
└── fsharp-kata-fizzbuzz.sln
</code></p>

<h3>Current state</h3>

<p>This is the current state of our test:
<code>`fsharp
[&lt;Fact&gt;]
let</code>Array with Number 1 returns &lsquo;one&rsquo;`` () =</p>

<pre><code>let result = FizzBuzz.Generate [1]
Assert.Equal(result, "one")
</code></pre>

<p>```</p>

<ul>
<li><code>[&lt;Fact&gt;]</code>: this is F#&rsquo;s annotation style. The same as C# <code>[Fact]</code> or Java <code>@Fact</code></li>
<li><code>Array with Number 1 returns 'one'</code>: Method name in double back-ticks improves readability, especially in unit tests. No CamelCasing or snake_casing needed. It&rsquo;s an F# language feature.</li>
<li><code>Assert.Equal(...)</code>: This is probably familiar to everyone who has ever written a unit test. Every assertion library has a different signature: Is it <code>Equal(expected, actual)</code> or <code>Equal(actual, expected)</code>? I hate this! Thankfully there are alternative assertion libraries. Example: In C# you can write <code>actual.Should().Be(expected)</code> (using <a href="http://fluentassertions.com/"><code>FluentAssertions</code></a>). The same is true for F#.</li>
</ul>


<h3>FsUnit: Idiomatic assertions</h3>

<p>What does &ldquo;idiomatic&rdquo; mean? For programming languages, it means: Writing code as most people, who are used to the language, would write the code (how a &ldquo;native&rdquo; would express an idea, a concept, an algorithm, etc). Simple example: In Java and JS, the first character of a method name should be lower case. In C#, the first character should be upper case (yes, even if the method is private!). The code will still compile if you don&rsquo;t comply to these conventions, but it&rsquo;s not &ldquo;idiomatic&rdquo;. Same goes for &ldquo;For Loops&rdquo; vs using a &ldquo;Map&rdquo; functions: In some languages one concept is preferred over the other.</p>

<p><code>FsUnit</code> brings <strong>pipes</strong> to F# unit tests. Pipes are used extensively in F# and should be familiar to most linux shell users: Bash uses the <code>|</code> symbol as operator to redirect the output of one expression to the input of another expression. In F# the pipe operator is <code>|&gt;</code>. The concept might seem similar to using &ldquo;Method Chaining&rdquo; in C# (it&rsquo;s not, but close enough in this context).</p>

<p>Example:
```fsharp
// instead of
Assert.Equal(1 + 1, 2)</p>

<p>// idiomatic F# (using pipe) with FsUnit:
1 + 1 |> should equal 2
```</p>

<h4>Installing FsUnit</h4>

<p><code>sh
cd FizzBuzz.Tests
dotnet add package FsUnit.Xunit
</code></p>

<p>File <code>FizzBuzz.Tests/FizzBuzz.Tests.fsproj</code> should now look like this (plus/minus some version numbers):
```xml
<Project Sdk="Microsoft.NET.Sdk"></p>

<p>  <PropertyGroup></p>

<pre><code>&lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;

&lt;IsPackable&gt;false&lt;/IsPackable&gt;
</code></pre>

<p>  </PropertyGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;Compile Include="Tests.fs" /&gt;
&lt;Compile Include="Program.fs" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;PackageReference Include="FsUnit.Xunit" Version="3.0.0" /&gt;
&lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.5.0" /&gt;
&lt;PackageReference Include="xunit" Version="2.3.1" /&gt;
&lt;PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" /&gt;
&lt;DotNetCliToolReference Include="dotnet-xunit" Version="2.3.1" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;ProjectReference Include="..\FizzBuzz\FizzBuzz.fsproj" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p></Project>
```</p>

<p>Note the line <code>&lt;PackageReference Include="FsUnit.Xunit" Version="3.0.0" /&gt;</code> (your version number might differ).</p>

<h4>Using FsUnit</h4>

<p>Modify the test file <code>FizzBuzz.Tests/Tests.fs</code> to look like this:
```fsharp
module Tests</p>

<p>open System
open FsUnit.Xunit // &lt;&mdash; add FsUnit.Xunit
open Xunit
open FizzBuzz</p>

<p>[<Fact>]
let <code>Array with Number 1 returns 'one'</code> () =</p>

<pre><code>FizzBuzz.Generate [1] 
|&gt; should equal "one" // using "|&gt;" and "should" syntax
</code></pre>

<p>```</p>

<p>Running the unit tests within the test folder:</p>

<p>```sh
dotnet test
Build started, please wait&hellip;
Build completed.</p>

<p>Test run for /home/patrick/projects/fsharp-blog-fizzbuzz/fsharp-kata-fizzbuzz/FizzBuzz.Tests/bin/Debug/netcoreapp2.0/FizzBuzz.Tests.dll(.NETCoreApp,Version=v2.0)
Microsoft &reg; Test Execution Command Line Tool Version 15.5.0
Copyright &copy; Microsoft Corporation.  All rights reserved.</p>

<p>Starting test execution, please wait&hellip;
[xUnit.net 00:00:00.7436128]   Discovering: FizzBuzz.Tests
[xUnit.net 00:00:00.8627111]   Discovered:  FizzBuzz.Tests
[xUnit.net 00:00:00.8695487]   Starting:    FizzBuzz.Tests
[xUnit.net 00:00:01.1888259]   Finished:    FizzBuzz.Tests</p>

<p>Total tests: 1. Passed: 1. Failed: 0. Skipped: 0.
Test Run Successful.
Test execution time: 2.4787 Seconds
```</p>

<h3>Summary</h3>

<p>We can now write unit tests in an F# way (&ldquo;idiomatic&rdquo;) by using the library <code>FsUnit</code>.</p>

<p>Have fun with F# and linux!</p>

<p>Get the source code <a href="https://github.com/draptik/blog-fsharp-fizzbuzz-setup">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[F# Setup Linux: FizzBuzz]]></title>
    <link href="http://draptik.github.io/blog/2018/02/05/fsharp-setup-linux-fizzbuzz/"/>
    <updated>2018-02-05T22:31:04+00:00</updated>
    <id>http://draptik.github.io/blog/2018/02/05/fsharp-setup-linux-fizzbuzz</id>
    <content type="html"><![CDATA[<p>One of the first things I always struggle with when learning new languages is the environment. Here is a simple setup for playing with F# and Linux.</p>

<h2>Prerequisite: .NET Core with Linux</h2>

<p>I won&rsquo;t go into setting up .NET Core for linux. This should be straightforward either by following <a href="https://docs.microsoft.com/en-us/dotnet/core/linux-prerequisites?tabs=netcore2x">Microsoft instructions</a> or, in my case, the <a href="https://wiki.archlinux.org/index.php/.NET_Core">Arch Linux homepage</a>. <code>dotnet --info</code> should return something similar to:</p>

<p>```
.NET Command Line Tools (2.1.3)</p>

<p>Product Information:
 Version:            2.1.3
 Commit SHA-1 hash:  a0ca411ca5</p>

<p>Runtime Environment:
 OS Name:     arch
 OS Version:
 OS Platform: Linux
 RID:         linux-x64
 Base Path:   /opt/dotnet/sdk/2.1.3/</p>

<p>Microsoft .NET Core Shared Framework Host</p>

<p>  Version  : 2.0.5
  Build    : 17373eb129b3b05aa18ece963f8795d65ef8ea54
```</p>

<h2>Creating a Kata</h2>

<p>Let&rsquo;s create a project for the FizzBuzz Kata.</p>

<p><code>
mkdir fsharp-kata-fizzbuzz
cd fsharp-kata-fizzbuzz
dotnet new classlib -lang f# -o FizzBuzz
dotnet new xunit -lang f# -o FizzBuzz.Tests
cd FizzBuzz.Tests
dotnet add reference ../FizzBuzz/FizzBuzz.fsproj
cd ..
dotnet new sln
dotnet sln add FizzBuzz/FizzBuzz.fsproj
dotnet sln add FizzBuzz.Tests/FizzBuzz.Tests.fsproj
</code></p>

<p>(I really love this new &ldquo;CLI first&rdquo; approach! It makes live so much easier for DevOps)</p>

<p>This is our project structure after templating:</p>

<p><code>
tree . -L 4
.
├── FizzBuzz
│   ├── bin
│   │   └── Debug
│   │       └── netstandard2.0
│   ├── FizzBuzz.fsproj
│   ├── Library.fs
│   └── obj
│       ├── Debug
│       │   └── netstandard2.0
│       ├── FizzBuzz.fsproj.nuget.cache
│       ├── FizzBuzz.fsproj.nuget.g.props
│       ├── FizzBuzz.fsproj.nuget.g.targets
│       └── project.assets.json
├── FizzBuzz.Tests
│   ├── bin
│   │   └── Debug
│   │       └── netcoreapp2.0
│   ├── FizzBuzz.Tests.fsproj
│   ├── obj
│   │   ├── Debug
│   │   │   └── netcoreapp2.0
│   │   ├── FizzBuzz.Tests.fsproj.nuget.cache
│   │   ├── FizzBuzz.Tests.fsproj.nuget.g.props
│   │   ├── FizzBuzz.Tests.fsproj.nuget.g.targets
│   │   └── project.assets.json
│   ├── Program.fs
│   └── Tests.fs
└── fsharp-kata-fizzbuzz.sln
</code></p>

<p>The 3 project files (top &ndash; down)&hellip;</p>

<p><code>fsharp-kata-fizzbuzz.sln</code> (nothing new here)
```
Microsoft Visual Studio Solution File, Format Version 12.00</p>

<h1>Visual Studio 15</h1>

<p>VisualStudioVersion = 15.0.26124.0
MinimumVisualStudioVersion = 15.0.26124.0
Project(&ldquo;{F2A71F9B-5D33-465A-A702-920D77279786}&rdquo;) = &ldquo;FizzBuzz&rdquo;, &ldquo;FizzBuzz\FizzBuzz.fsproj&rdquo;, &ldquo;{C64F3370-DE54-4D58-BDD4-33C4B02F7290}&rdquo;
EndProject
Project(&ldquo;{F2A71F9B-5D33-465A-A702-920D77279786}&rdquo;) = &ldquo;FizzBuzz.Tests&rdquo;, &ldquo;FizzBuzz.Tests\FizzBuzz.Tests.fsproj&rdquo;, &ldquo;{4AA6DACD-EA0E-4938-BB41-7B055A9A0C8C}&rdquo;
EndProject
[&hellip;]
```</p>

<p><code>FizzBuzz/FizzBuzz.fsproj</code> (not relevant here, but keep in mind that fsharp files have to be in the correct order):
```xml
<Project Sdk="Microsoft.NET.Sdk"></p>

<p>  <PropertyGroup></p>

<pre><code>&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
</code></pre>

<p>  </PropertyGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;Compile Include="Library.fs" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p></Project>
```</p>

<p><code>FizzBuzz.Tests/FizzBuzz.Tests.fsproj</code>:
```xml
<Project Sdk="Microsoft.NET.Sdk"></p>

<p>  <PropertyGroup></p>

<pre><code>&lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;

&lt;IsPackable&gt;false&lt;/IsPackable&gt;
</code></pre>

<p>  </PropertyGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;Compile Include="Tests.fs" /&gt;
&lt;Compile Include="Program.fs" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.5.0" /&gt;
&lt;PackageReference Include="xunit" Version="2.3.1" /&gt;
&lt;PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" /&gt;
&lt;DotNetCliToolReference Include="dotnet-xunit" Version="2.3.1" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p>  <ItemGroup></p>

<pre><code>&lt;ProjectReference Include="..\FizzBuzz\FizzBuzz.fsproj" /&gt;
</code></pre>

<p>  </ItemGroup></p>

<p></Project>
```</p>

<p>Running <code>dotnet test</code> returns</p>

<p>```
$ dotnet test
Build started, please wait&hellip;
Build started, please wait&hellip;
Build completed.</p>

<p>Test run for /home/patrick/projects/fsharp-blog-fizzbuzz/fsharp-kata-fizzbuzz/FizzBuzz/bin/Debug/netstandard2.0/FizzBuzz.dll(.NETStandard,Version=v2.0)
Microsoft &reg; Test Execution Command Line Tool Version 15.5.0
Copyright &copy; Microsoft Corporation.  All rights reserved.</p>

<p>Starting test execution, please wait&hellip;
No test is available in /home/patrick/projects/fsharp-blog-fizzbuzz/fsharp-kata-fizzbuzz/FizzBuzz/bin/Debug/netstandard2.0/FizzBuzz.dll. Make sure test project has a nuget reference of package &ldquo;Microsoft.NET.Test.Sdk&rdquo; and framework version settings are appropriate and try again.</p>

<p>Test Run Aborted.
Build completed.</p>

<p>Test run for /home/patrick/projects/fsharp-blog-fizzbuzz/fsharp-kata-fizzbuzz/FizzBuzz.Tests/bin/Debug/netcoreapp2.0/FizzBuzz.Tests.dll(.NETCoreApp,Version=v2.0)
Microsoft &reg; Test Execution Command Line Tool Version 15.5.0
Copyright &copy; Microsoft Corporation.  All rights reserved.</p>

<p>Starting test execution, please wait&hellip;
[xUnit.net 00:00:00.9263576]   Discovering: FizzBuzz.Tests
[xUnit.net 00:00:01.0646319]   Discovered:  FizzBuzz.Tests
[xUnit.net 00:00:01.0733357]   Starting:    FizzBuzz.Tests
[xUnit.net 00:00:01.2961789]   Finished:    FizzBuzz.Tests</p>

<p>Total tests: 1. Passed: 1. Failed: 0. Skipped: 0.
Test Run Successful.
Test execution time: 2.5956 Seconds
```</p>

<p>Ok, <code>dotnet test</code> does not recognize which project actually contains tests. But it runs all tests!</p>

<p>Let&rsquo;s add a test.</p>

<p>The file <code>FizzBuzz.Tests/Tests.fs</code> (generated by <code>dotnet new xunit...</code>) looks like this:
```fsharp
module Tests</p>

<p>open System
open Xunit</p>

<p>[<Fact>]
let <code>My test</code> () =</p>

<pre><code>Assert.True(true)
</code></pre>

<p>```</p>

<p>TDD approach: We will create a failing test first, then implement something.</p>

<p>Replace the content of <code>FizzBuzz.Tests/Tests.fs</code> with</p>

<p>```fsharp
module Tests</p>

<p>open System
open Xunit
open FizzBuzz</p>

<p>[<Fact>]
let <code>Array with Number 1 returns 'one'</code> () =</p>

<pre><code>let result = FizzBuzz.Generate [1]
Assert.Equal(result, "one")
</code></pre>

<p>```</p>

<p>We verify 2 aspects:</p>

<ul>
<li>we are invoking another library (<code>FizzBuzz</code>) from our test class</li>
<li>we are learning to use the test library</li>
</ul>


<p>This does not compile. Let&rsquo;s implement the simplest solution:</p>

<p>Replace <code>FizzBuzz/Library.fs</code> with
```
module FizzBuzz</p>

<p>let Generate i = &ldquo;one&rdquo;
```</p>

<p>Running <code>dotnet test</code> should now confirm 1 passing test.</p>

<p>Have fun with F# on Linux!</p>

<p>Get the source code <a href="https://github.com/draptik/blog-fsharp-fizzbuzz-setup">here</a></p>
]]></content>
  </entry>
  
</feed>
